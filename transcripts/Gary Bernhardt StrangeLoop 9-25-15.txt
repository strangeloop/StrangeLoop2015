   Gary Bernhardt:  "Ideology"
   
   (Live captioning by White Coat Captioning @whitecoatcapxg) 
   
   >> Hello, can everyone hear me? I guess you can't actually answer because I can't even see you:
   AUDIENCE MEMBER:  Hi Gary!
   >> Hello. All right, I am Gary Bernhardt, this is a talk called Ideology. I want to contextualize this talk with something that I think is very culturally relevant, the thing that you see on the screen, the belief that many of us have that we are not real programmers for some amorphous definition of real. The danger or the terrible thing about this belief is that it functions even if you don't know that you believe it. And the wonderful thing about the term that we have for it, imposter syndrome, is that upon hearing the term, people can suddenly realize that they've had this belief for years or in some cases decades and that that it was, working even though they didn't know they had it. This talk isn't about imposter syndrome but we're going to look for this kind of belief often that programmers make claims like I write tests so I don't need types. We're going to look for people believe when they say things like this. The title as I said, is ideology, I am Gary Bernhardt, and when I use the word ideology in this talk, I mean it in a very specific way. I don't mean the cable news network definition or the popular pop culture definition of just political belief and to see what I mean we'll take a brief detour to Donald Rumsfeld before we get into computers. He once said something about known knowns, unknown unknowns, which earned him ridicule because he made fine-grained differentials between the words. There are things in the world that we know and we know that we know them. So known knowns, for example, Turing equivalent computers cannot solve the halt prom. When given a second arbitrary program decides when that second program terminates or not we know this, we have proofs going back to 1936. It's a known known. There are other things that we don't know, but we at least know that we don't know them. Known unknowns. For example, does P equal NP. We know this question very well. So it is a known unknown. And finally, there are things that we don't know and we don't even know that we don't realize it. Unknown unknowns. And this is what Rumsfeld was talking about because he was talking about war and the classic example of this is that the Japanese attack on Pearl Harbor, it's the concept that the attack wasn't something that they were worried about.
   And this is where Rumsfeld stopped, because he's not a programmer and he is happy to see two binary variables and only three entries in a table.
   [laughter]
   >> But this being Strangeloop, let's scoot this up, and the obvious fourth entry their is things that you know but you do not know that you know them and this is what I mean by the worked ideology in this talk.
   >> This is the type of belief that imposter syndrome is, it functions even though you don't know it's there.
   >> So now we can finally get to computer things. I want to begin for our first example with a pair of beliefs, a pair of claims that are often made by static language advocates versus dynamic language advocates, but that means I have to define what I mean by static, so in this talk we're talking about ML families of languages, we're talking about Haskell, we're talking about Rust maybe to a lesser extent. When I say these things, I don't mean C and Java and other curly braced languages.
   >> So these two statements that people make about types and tests. The first is going to be uttered by a hypothetical static language advocate and they say Python needs tests because there's no type checker. I've everyone's heard this before. This is a thing that people say. On the other hand, dynamic language advocates will sometimes say I write tests anyway, so I don't need a type checker and these are sort of exact opposite statements. So either tests and types are deeply equivalent in a way that we've never really discovered but somehow these people know, or somebody is wrong. And I think it's the second thing.
   [laughter]
   So let's dig into the way that these two programmers think about correctness, because correctness is really what we're talking about here, and the way that the languages that they use inform their understanding of what correctness even is, and we'll start with a dynamic language programmer. We're going to use an example of converting an RGB color to an HSV function. We're not even going to look at the body, it just does some math on the color components and hopefully a dynamic language programmer is going to write some tests. Maybe they write a test for a medium gray, a test for a white, a test for a black, and hopefully some nongray-scale colors, as well, and they end up with all these points where they have written these very specific tests. They show the behavior of the system in this one exact situation and from this, they infer that now the program is correct in this -- for this sort of region of program behavior of RGB inputs.
   >> Around this, there is this region of undefined behavior that the dynamic languages forces to be a valid are program in the sense that it will run, but the programmer has not considered what will happen. Things like what if there's a negative number number? Hopefully the programmer thought of that and wrote a test. Probably a lot of people would not. What if there's a number greater than 1, because the color components are 0 to 1 value range. What if we pass in integers instead of floats? Well, if it's JavaScript there is no integers so it doesn't matter, if it's Python two. There are integers. So in Python it actually depends on the version of the language.
   >> What if we pass in an extra element in the tuple will? What if we pass in null this is the ever-present question that most programmers don't consider for most functions because it would be exhausting to do so and what happens if we pass? Something like a date time? Well, Ruby's date time defines most of the mathematical operators for reasons.
   [laughter]
   And so this may actually return a value and of course in JavaScript this will return nonsense, because all expressions in JavaScript return something.
   [laughter]
   So this is the reality of dynamic language programming which everyone who uses those languages knows but doesn't like to talk about. Of course there is this central region of behavior and so maybe we think that.7 will give us the correct conversion or.3 even though we never wrote tests for those, so the reality is that that behavior is also undefined in the sense that we don't have any concrete evidence of what it's going to do. We just make that inference in our minds that these tests, these points turn into a generalized region of program behavior. Usually that belief is correct. Sometimes it's not and that's why bugs happen and the sort of way to summarize all of this is that tests are only examples. They do not establish categories of behavior. They can't do it.
   Humans imagine that they do it, but that is -- that is not actually true.
   So that is dynamic the dynamic language programmer's sort of view of correctness. They have to make this sort of leap of faith that is not justified by any kind of objective reasoning. #.
   Now, let's turn to static languages. If you think I'm picking on dynamic language programmers, just wait.
   [laughter]
   A static language programmer is going to start by, unsurprisingly defining some types. Here we have an RGB type that's 3 doubles. HSV type that's three doubles. We'll define a function who is type is RGB to HSV. Returns an HSV tuple. Not surprising and now we have in this same region of programming behavior that the dynamic programmer had. And again it contains things like 000, 111, we believe that the conversion will happen correctly for all these values.
   But that undefined space is now impossible, and this is the most obvious implication of a static type system. It makes all of these -- all of those undefined, all of those undesirable situations compilation errors, so we cannot pass in ha fourth value in the tuple, because this is not a legal program. In a dynamic language we have to ask ourselves what are the semantics of this and we have to ask ask that for an infinite um in of questions. Likewise for null which these languages don't have, so that problem goes away. Likewise for things like passing in a date time or passing in an HSV when an RGB is expected. All the standard static typing stuff.
   But what about these cases? Negative numbers and numbers greater than 1? Well, if you're in Idris, then you, I don't know, write a proof somehow, I don't really understand how that happens. But by magic a compiler can make these impossible situations. But in most static functional languages we don't have that capability. So there's this region of the category of behavior that we told the type system is allowed. That is actually wrong. And so what we're seeing here is types are only categories, and specifically the granularity of the categories is limited by the type system and in current languages it's still quite coarse. Current mainstream functional languages.
   So hopefully the static language programmer writes some tests in there, and characterizes that behavior, because that is the only path they have left. The type system cannot do it. And they probably use quick check or something fansly like that, as opposed to the more vulgar tools that are used in most dynamic languages, but still, they need tests and they have to make that same inference, that same jump to believing that they've characterized that region even though they only have examples.
   Quick check just makes more examples. So these are two very different ways to think about programming and the languages force you into these ways of thinking about programming and specifically about correctness. And now we can go back to these things that these two people arguing with these other say: When a static language programmer says that Python needs tests because there's no type checker, I think it is motivated by a belief that they won't state, they probably won't even own up to, but I think the belief that's functioning here is that correctness comes exclusively from categories, which would be true if you had an arbitrarily powerful type system which you you don't.
   Now, you won't get them to say this, they will deny this, and that is how these kinds of beliefs function, they structure the things you're saying and maybe this one is not quite so obvious but I think for the dynamic language programmer, it is much more obvious that they believe that correctness comes from examples because they've never used a static type system so when they think that this other thing that people use to try to form beliefs why correctness, they can only imagine it in terms of what they know, tests, which are a totally different thing. So they say things like I write tests anyway so I don't need a type checker because they've incorrectly imagined what a type checker is.
   Now both of these statements and beliefs are extreme versions partly because I have to kind of make things move along quickly, but also because I think that these are real beliefs and if that seems like a strange idea to you, just go read Hacker News for a few days and you'll see people saying these things. They'll use more words and probably be meaner but they'll be saying these things.
   Now I want to accelerate because I don't want to slowly deconstruct all this stuff for hours. So let's talk about null briefly. In a dynamic language null lives within that specifically undefined space. The place where a tuple lives. If we wrote all those tests, we'd have just so many tests that usually didn't provide any value show we just live with the uncertainty and of course the way that manifests as anyone who has built a large system into a dynamic language knows is that one function generates a null and then it propagates and propagates and propagates and propagates through function calls and then eventually someone tries to add 4 to it or something and you get an exception and the exception occurs far away from the source of the null and the source of the null is no longer in the trace-back. So there's very little useful debugging information present. Of course in a static language this problem goes away because null is part of that impossible place, there is no such thing as null, so we don't have to think about it.
   And the reaction when people encounter this idea for the first time, some of them say, but I need null to program. Well, that's what they say. I need null. People say this now, in fact this was motivated by a Hacker News thread when I was preparing this talk. This is a thing that I actually saw someone say when I was working on this talk. And this only makes sense that you believe that null is the only way to represent absence, because what you really need to do is represent nothingness or the absence of a value. But if you only know one way to do it, then you sort of make this leap and say, well that must be the only way, null must be the only way.
   But you won't get them to say the bottom thing, right, because if they even realized that they believed that, they could have asked the static language programmer is that actually true, how do you represent nothingness. But they just said programming in that language is impossible, that language you use, which is a very silly thing to say.
   [laughter]
   Going back further in time if we go about five years I think it was very common for people to believe that functional programming is inherently slow, not just I used language X and wrote some slowed code but that functional program is in a universal sense slow.
   And this really mostly comes down to data structures. If you are thinking of naive implementation of arrays and lists, then functional programming is slow. Because every time you -- you have to copy everything over and it's very slow. But if you have persistent data types, like Clojure does, for example, then this isn't a problem so in order to say that FP is slow, you have to believe, maybe without realizing it that no faster mutable types exist but for persistent data types date back to at least 96. So this was false long before the person ever said this. The top thing is false that is, long before they ever said it. Because the bottom thing is false. Going back further to 2000, this was one of my favorite things to argue about when I was just starting college at this time, that garbage collection is never going to be practical for real-world software. I loved arguing about that. I believed that it was true by the way, not the other way, I had the wrong belief.
   And much like the functional programming thing, this only makes sense if there are no better GC algorithms coming. Now, in 2000, my context for garbage collection was the JVM and this was just before it got much better garb, so I was thinking about the one second GC pause. But what I failed to realize that that those massive GC improvements were coming and they were based on work for the 80s and in many cases the 70s, so before I was alive, I was already wrong about this and I just needed to be a college student who liked arguing about of it really came out.
   So I'm going to stop going through individual examples right now. I think the pattern is clear. You say the top thing, it only makes sense if the bottom thing is true, so in a sense you believe the bottom thing. It's structuring your your understanding of the world, but you don't realize it. If we kind of group these up, the belief that no faster immutable types exist, and the belief that no faster GC mutable types exist and the belief that only null can represent absence, these are all kind of the same belief. This is the belief that I saw something with property X, therefore the category of things has property X. I saw slow fung functional code, therefore, functional code will always be slow, etc. These are actually quite easily to dispel. When someone believes theses things you just tell them of the existence of the alternative and some people will be stubborn and claim that that alternative doesn't exist or something. But for the most part people will believe you and the belief goes away.
   The correctness comes exclusively from categories and correctness comes exclusively forever examples, I can find myself believing both of these today depending on what I'm doing. If I'm programming in O cam L, I stop thinking about exceptions to the types that I am creating and in a dynamic language, I write the 0, 1, many, a lot test and then I sort of don't think about, are there members of the category I just established that should not be there?
   >> Right, did I fail to actually define the category?
   And I don't know how to stop doing this, but I think realizing it is important, mostly because it will make you pa better programmer but also because it will make you stop writing angry hacker news comments. It's important to note that imposter syndrome is also in this category. Even when you know you have this belief it still functions, it still governs the way you think of yourself in this case as opposed to understanding software.
   So this bottom category is the one that's scary. The top one is just sort of an inconvenience. And if you could turn ideology about technical topics into sort of a substance, like a fluid and pour it into a vessel of some kind, I think that vessel would be Hacker News, whether we're talking about type systems or tests, dynamic or static, whether we're talking about the meritocracy or the market, if you just read any Hacker News thread that it has a lot of comments and is a contentious topic you can find people where you see the things they believe but don't realize they believe. It's just staring you in the face and that makes it sound like maybe ideology is universally bad but the first time I gave this talk I think I gave that impression, so I'll had just note one bit of ideology that is very nice to have is that the belief that hurting people is bad. You don't have to consciously stop every time this comes up and think, is hurting people bad? It just kind of works even when you don't consciously think about it. It's not that the world of structuring beliefs are bad, it's just that it's powerful and they lead us to treat each other badly and also making bad technical decisions. So that is ideology. My name is Gary Bernhardt. I feel compelled to read the slide every time. If you're interested in this idea of ideology and it is not familiar to you, this has been a very vulgar introduction to it in the sense that I don't really know what I'm talking about in cultural or theoretical things, but theres' a film called the pervert's guide tittediology and I will not tell you that you will agree with every single thing in it but I will tell you that you will at the very absolutely be entertained and enter do be put off by the word pervert in the title. If you're interested in static type systems and they are not familiar to you and this sort of section made you realize that you have not fully understood what they are, there is a wonderful course from Dan Grossman who's a professor at the university of Washington, CSE341, it's a languages course but the entire first half is in SML and is very approachable. The second half of the course is also fantastic. Everyone in this room can take this course and understand why static types are a big deal and finally as for myself I've been working on a book that is an attempt to take all the sort of major interesting topics in computer science in like an undergraduate degree squish them into a book removing all the mathematical rigor to try to give an introduction to these things to people who are programmers about you don't have a formal background so if that's interesting, you can get an e-mail when it finally is available. With that, I thank you all very much for coming :
   [applause]
   I assume that we have time. Yeah. As usual, I have no idea what questions could possibly look like for this talk, but I welcome attempts. If there are any. Yeah? I can't really see well. I see a hand.
   >>
   AUDIENCE MEMBER:  You talk a lot about ideology and recognizing something as an ideology, but once you have that information what do you with that?
   >> What do you do once you see ideology in your own thoughts? Someone who's watched the pervert's guide to ideology, but in some -- so in if we think about like the functional programming one, right, the belief that functional programming is inherently slow, once you think the underlying belief, the thing you said no longer makes sense. It just kind of goes away. The harder ones, I struggle with it, I struggle with trying to get myself to think in terms of both categories and examples when I'm building software, right? Especially in dynamic languages it's very hard to think about categories because there's no system in there but just knowing that I make that mistake causes me to pause and think about it. So I don't think there's really a process. Just trying to -- it's really just trying to engage in metacognition if we make it abstract just trying to think about your own thoughts is obviously always a good thing. I mean sometimes it will make you sad. What time is it? Yeah, we still have plenty of time. If there's more, I can't see well so you might have to shake your hand around a lot.
   AUDIENCE MEMBER:  So you mentioned earlier that a lot of type systems don't have -- but I can think of some that do, like incredibly popular java, for example, but it seemed electrically like in your perspective those are synonymous. A good system doesn't have node. How do you square those two?
   >> I'm trying to restate. How do I square the existence of don't have node with my implication that those systems are not static or that staticness requires node. it's not that I'm -- I mean Java is a statically typed language but it's a different kind of language, right, it's a much weaker type system and I think actually the existence of null is probably the best indicator of you can get as to whether a type system is any good or not.
   [applause]
   A, this is the right crowd for this for sure. If I said that at RubyConf, they'd say hm? That sounded mean. I didn't mean that to be mean. Let's do one more.
   AUDIENCE MEMBER:  
   Ideology about how you you know, you have the categories and like they give you some structure but then you would say once you're in your function am I able to answer this question, so what if the number is negative, what if it's basically the right category, but still: So what about you know, a search and just checking that telling whoever called you about it can't answer.
   >> Right, in the case of whether we had negative color components, about what assertions? I mean assertions are you, well, OK, the dismissive way to say it is assertions are you reinventing a type system badly but the less judgmental and practical way of saying it is you filling in holes in a type system. Right? Things that a type system cannot express. I mean, that will certainly fill in those holes to some extent, but the problem is, that you also need evidence that the assertion was written correctly, right? Because if you -- I mean in this case it's simple but a complex assertion, you're sort of devolving into a situation where you even need to test to know that the assertion is right.  Because there's no test about the assuring that the assertion is right and I'm one inch away from showing how ignorant I am of formal type systems. But I think it's another example of the same thing. Like I would put an assertion in the test bucket, no the in the type system bucket. That's probably a much briefer answer. I'm going to stop holding you hostage. Thank you all very much.
   [applause]
